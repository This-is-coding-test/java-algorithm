# SECTION 9. 그리디 알고리즘

## 씨름 선수

A라는 지원자를 다른 모든 지원자와 일대일 비교해서 키와 몸무게 모두 A지원자 보다 높은 (크고, 무겁다) 지원자가 존재하면 A지원자는 탈락하고, 그렇지 않으면 선발된다.

해당 문제는 키를 내림차순으로 정렬하고 키는 이미 크기 때문에 몸무게만 비교하면 된다.

1중 for문으로 처리할 수 있기 때문에 O(N)으로 가능하다.

## 회의실 배정

앞 문제인 씨름 선수와 비슷한 문제였는데 끝나는 시간을 내림차순으로 정렬하고 만약 끝나는 시간이 같을 경우 시작 시간을 기준으로 내림차순으로 정렬한다.

## 결혼식

위 두문제와 같은 유형의 문제인 줄 알았는데 해당 문제는 시작 시간과 종료 시간을 나눠서 객체로 관리해야 했다.

시작 시간의 경우 count를 증가시키고 종료 시간일 경우 count를 감소시킨다.

최종 결과 변수인 result는 count의 max값을 저장한다.

## 최대 수입 스케쥴(PriorityQueue 응용문제)

![KakaoTalk_20220906_182528857](https://user-images.githubusercontent.com/83503188/188847868-774361db-d1c9-4768-b7be-ea30a2784110.jpg)

## 다익스트라 알고리즘

정점 크기의 dist 배열을 선언하고 배열을 `Integer.MAX_VALUE` 로 초기화한다.

그래프 리스트를 통해 그래프를 나타내고 우선순위 큐를 통해 현재 dist 배열에 가장 작은 value를 찾는다.

우선순위 큐를 사용하지 않고 배열을 순회할 수 있지만 정점이 많은 경우라면 쓸데없는 시간을 소비하게 된다.

## 친구인가?
![KakaoTalk_20220907_181306080](https://user-images.githubusercontent.com/83503188/188847881-45488881-8eaa-4fe7-aede-f07a50ae34bd.jpg)

## 원더랜드(최소스패닝트리 : 크루스칼, Union&Find 활용)

크루스칼 알고리즘은 비용을 기준으로 내림차순 정렬을 하고 리스트를 순회하며 사이클이 형성되는지를 Union&Find 기법을 통해 확인하는 문제다.

## 원더랜드(최소스패닝트리 : 프림, PriorintyQueue)

![KakaoTalk_20220907_184533368](https://user-images.githubusercontent.com/83503188/188847888-9145b583-697f-4d44-b236-bab53247086b.jpg)









