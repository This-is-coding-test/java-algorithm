# Dynamic programming(동적계획법)

## 계단오르기 

N 크기에 해당하는 dp 배열을 선언한다. => `int[] dp = new int[N]`

해당 배열의 값은 인덱스 위치의 계단에 오를 때의 최대 방법의 수다. 예를들어, dp[1]은 계단 1칸을 오를 때 방법의 수이다.

따라서 dp[1] => 1(1) , dp[2] => 2(1 + 1, 2)가 된다. dp[3]은 dp[1]에서 2칸 올라오거나, dp[2]에서 1칸 올라오는 경우이므로 dp[3] = d[1] + dp[2]가 된다. 

=> `dp[N] = dp[N - 1] + dp[N - 2]`

## 최대 부분 증가수열

N 크기에 해당하는 dp 배열을 선언한다. => `int[] dp = new int[N]`

해당 배열의 값은 인덱스 위치까지의 최대 증가수열이다. 

![KakaoTalk_20220913_222309455](https://user-images.githubusercontent.com/83503188/189912761-0a2ba561-6348-434d-b280-8fc544ee2123.jpg)

## 가장 높은 탑 쌓기 

N 크기에 해당하는 dp 배열을 선언한다. => `int[] dp = new int[N]`

해당 배열의 값은 인덱스가 가리키는 벽돌이 가장 꼭대기에 존재할 때의 높이다.

우선, 벽돌의 밑면 또는 무게를 기준으로 내림차순 정렬을 한다. 먼저 정렬을 하는 이유는 만약 밑면으로 정렬했다고 가정하면 무게만 고려하면 되기 때문이다.

![KakaoTalk_20220913_223333593](https://user-images.githubusercontent.com/83503188/189915059-f24902a1-0c8e-4368-8d9f-62a2b28b6702.jpg)


## 동전교환(냅색 알고리즘)

N 크기에 해당하는 dp 배열을 선언한다. => `int[] dp = new int[N]`

해당 배열의 값은 인덱스(i)원 일 때의 최소 동전 개수이다. 예를들어 dp[3]은 3원일 때의 최소 동전 개수가 된다. 

이 문제는 주어진 동전의 종류를 무한대로 사용할 수 있다. 

2중 for문을 이용하는데 outer for문은 동전의 종류이다. 따라서 (1, 2, 5)가 된다. inner for문은 해당 동전부터 N까지이다. 

여기서 dp를 갱신할 때 `dp[j] = Math.min(dp[j], dp[j - coin] + 1)` 를 이용하는데, 해당 코드는 coin이 5인 상태라면 dp[10] = Math.min(dp[10], dp[5] + 1)인데,

풀어보면 10원을 만들기 위해서는 이전에 갱신한 2원을 5개 사용하여 만들 수도 있지만, dp[5]인 5원을 만드는 최소 개수에서 5원을 하나 더 사용하여 총 2개로 만들 수도 있음을 의미한다. 

![KakaoTalk_20220913_224358475](https://user-images.githubusercontent.com/83503188/189917881-bf363ca0-eed2-4353-8d73-b8709697def8.jpg)

## 최대점수 구하기(냅색 알고리즘)

N 크기에 해당하는 dp 배열을 선언한다. => `int[] dp = new int[N]`

해당 배열의 값은 인덱스(i)분 일 때의 최대 점수이다.

해당 문제는 이전 동전교환과 달리 문제가 무한대로 가능한게 아닌 1번만 가능하므로 inner for문에서 M(제한 시간)부터 time까지만 돌면된다.
